"""
    A MessageProcessor is an object that encapsulates a function to
    manipulate post messages

    All derived classes must implement the process_message function

    This function takes the HTML object (from BeautifulSoup) of the message

"""
from bs4 import Tag

from vBulletinThreadUtils.html2bbcode import parse_children_in_node
from vBulletinThreadUtils.vBulletinFileUtils import close_thread_file, open_thread_file, get_thread_file_name, \
    write_message_to_thread_file


class MessageProcessor(object):
    """
        Interface for all kinds of message processor

        Every specialized class should implement the process_message method
        that reads a message and does some work on it

        The message is an HTML node as generated by beautiful soup that
        contains the table entry of the post
    """

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        raise NotImplementedError('Should have implemented this')


class MessageHTMLToText(MessageProcessor):
    """
        Converts the BeautifulSoup Tag object into a HTML string
        with all the formatting tags
    """

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        return message.prettify(formatter='minimal')


class MessageHTMLToTextAddingBorderToBlockquote(MessageProcessor):
    """
        This processor takes a message in XenForo format and adds a thin line
        around the blockquote sections via inline css style
    """

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        blockquotes = message.find_all('blockquote')
        for blockquote in blockquotes:
            blockquote['style'] = 'border-style: double;'
        return message.prettify(formatter='minimal')


class MessageHTMLToPlainText(MessageProcessor):
    """
        Removes all the formatting tags from the HTML object and
        returns the text of the message
    """

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        """
        :param post_id: not used
        :param thread_info: not used
        :param message: a bs4 Tag node
        :return: The plain text of the message, that is: the text with quotes and all formatting removed.
        """
        quotes = message.select('div > table > tr > td.alt2')
        if not quotes:
            pass
        for quote in quotes:
            # to handle quotes inside of quotes
            if not quote.decomposed:
                quote_root = quote.parent.parent.parent
                quote_root.decompose()
        scripts = message.select('script')
        for script in scripts:
            script.decompose()
        return message.text


class MessageHTMLToBBCode(MessageProcessor):
    """
        Converts HTML formatting into the original BBCode
    """

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        return parse_children_in_node(message)


def write_message_to_thread_file_only_html_tag(thread_file, thread_info, message_id, message_as_tag) -> None:
    """
        This is used by MessageHTMLToHTMLFile to write HTML files

    :param thread_file: the output file
    :param thread_info: the dictionary with all the parsed data
    :param message_id: the current message id
    :param message_as_tag: the HTML object of the current message
    :return: None
    """
    # don't want to change the thread metadata
    message = dict(thread_info['parsed_messages'][message_id])
    message['message'] = message_as_tag
    write_message_to_thread_file(thread_file, thread_info['id'], message_id, message)


class MessageHTMLToHTMLFile(MessageProcessor):
    """
        This class should work as the vBulletinFileUtils.save_parse_result_as_file

        Instead of process all the messages at once it will be done one by one
        The file is created and closed on the with guard methods

        We have to store the first message as it doesn't have all the info needed to create
        the output file.
    """

    def __init__(self):
        self.__has_all_data = False
        self.__first_message = None
        self.__first_message_id = ''
        self.__thread_file = None
        self.__thread_file_name = ''

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        close_thread_file(self.__thread_file)
        return self

    def process_message(self, thread_info: dict, post_id: str, message: Tag):
        if not self.__has_all_data:
            if not self.__first_message:
                self.__first_message = message
                self.__first_message_id = post_id
            else:
                self.__thread_file_name = get_thread_file_name(thread_id=thread_info['id'],
                                                                 thread_name=thread_info['title'])
                self.__thread_file = open_thread_file(thread_filename=self.__thread_file_name,
                                                        thread_name=thread_info['title'])
                write_message_to_thread_file_only_html_tag(
                    self.__thread_file, thread_info, self.__first_message_id, self.__first_message)
                write_message_to_thread_file_only_html_tag(self.__thread_file, thread_info, post_id, message)
                self.__has_all_data = True
                self.__first_message = None
        else:
            write_message_to_thread_file_only_html_tag(self.__thread_file, thread_info, post_id, message)
