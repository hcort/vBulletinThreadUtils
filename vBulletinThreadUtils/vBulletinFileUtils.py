"""
    Some functions to handle writing parse results as HTML files.

    We can use external resource files to make the HTML output resemble the original website layout.
    If those files are not present then a minimal layout is generated via code.

    When working with a set of threads we can also build an "index" page where we can access all the
    HTML files generated by the parser.
"""
import io
import os
import re
from urllib.parse import urlparse

from bs4 import BeautifulSoup, Tag
from slugify import slugify

from vBulletinThreadUtils.vBulletinSession import vbulletin_session


def save_parse_result_as_file(thread_info, save_to_index=False, thread_index_file=''):
    """
        Main entry point to the file utils

        This method does all the work to save a thread (stored in the thread_info dictionary) into
        an HTML file

    :param thread_info: The parsed thread
    :param save_to_index: Adds this thread as an entry to the index file
    :param thread_index_file: The index file
    :return: Nothing
    """
    thread_messages = thread_info.get('parsed_messages', {})
    if not thread_messages:
        return
    thread_file_name = get_thread_file_name(thread_id=thread_info['id'],
                                            thread_name=thread_info['title'])
    thread_file = open_thread_file(thread_filename=thread_file_name,
                                   thread_name=thread_info['title'])
    for message in thread_messages:
        write_message_to_thread_file(thread_file=thread_file,
                                     thread_id=thread_info['id'],
                                     message_id=message,
                                     message=thread_messages[message])
    close_thread_file(thread_file)
    if save_to_index:
        _update_saved_threads_page(thread_info, thread_file_name, thread_index_file)


def generate_minimal_index_file():
    index_header = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
                   '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html ' \
                   'xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="es"><head>' \
                   '<meta name="robots" content="noarchive,noindex"/><meta http-equiv="Content-Type" ' \
                   'content="text/html"/><meta charset="UTF-8"><title>Índice</title></head>' \
                   '<body><table class="tborder" cellpadding="5" cellspacing="1" border="0" ' \
                   'width="100%" align="center" id="threadslist"><tr><td class="thead" width="2%">&nbsp;</td>' \
                   '<td class="thead" width="75%">Tema / Autor</td>' \
                   '<td class="thead" width="150" align="center" nowrap="nowrap">Mensajes</td></tr>'
    return io.StringIO(index_header)


def get_index_file():
    index_filename = os.path.join(vbulletin_session.config['VBULLETIN']['resources'], 'search_index_header.txt')
    if os.path.exists(index_filename):
        return open(index_filename, 'r', encoding='utf-8')
    else:
        return generate_minimal_index_file()


def _open_index_file(search_id=''):
    output_dir = vbulletin_session.output_dir
    if search_id:
        filename = f'search_{search_id}.html'
    else:
        filename = 'index.html'
    filename = os.path.join(output_dir, filename)
    if os.path.exists(filename):
        os.remove(filename)
    # 'iso-8859-1', 'cp1252'
    index_file = open(filename, 'a+', encoding='utf-8')
    for line in get_index_file():
        index_file.write(line)
    return index_file


def _create_saved_threads_file(filename):
    if not os.path.exists(filename):
        index_file = open(filename, 'a+', encoding='utf-8')
        for line in get_index_file():
            index_file.write(line)
        index_file.write('</table></body></html>')
        index_file.close()


def generate_minimal_entry_pattern():
    entry_pattern = '<tr id="tr_thread_{id}"><td id="thread_{id}_idx" class="alt2">{idx_link}</td><td class="alt1" ' \
                    'id="td_threadtitle_{id}" title="{hover}"><div><a href="{url}" id="thread_title_{id}">{title}</a>' \
                    '<span class="smallfont" style="white-space:nowrap">{url}</span></div><div class="smallfont">' \
                    '<a href="{url_base}member.php?u={author_id}">{author}</a></div></td><td class="alt2" ' \
                    'title="Fichero"><div id="thread_{id}_msgcnt" class="smallfont" style="text-align:center; ' \
                    'white-space:nowrap"><a href="{thread_file_name}"> {author_matches} mensajes</a></div></td></tr>'
    return io.StringIO(entry_pattern)


def get_pattern_file():
    pattern_filename = os.path.join(vbulletin_session.config['VBULLETIN']['resources'], 'index_file_entry_pattern.txt')
    if os.path.exists(pattern_filename):
        return open(pattern_filename, 'r', encoding='utf-8')
    else:
        return generate_minimal_entry_pattern()


def _build_table_entry(num_link, thread_info, thread_file_name):
    with get_pattern_file() as pattern_file:
        entry_pattern = pattern_file.read()
        return entry_pattern.format(id=thread_info['id'], idx_link=num_link, url=thread_info['url'],
                                    title=thread_info['title'],
                                    hover=thread_info['hover'], author=thread_info['author'],
                                    url_base=vbulletin_session.base_url,
                                    author_id=thread_info['author_id'],
                                    author_matches=len(thread_info['parsed_messages']),
                                    thread_file_name=thread_file_name)


def _insert_thread_saved_threads_file(filename, thread_info, thread_file_name):
    soup = BeautifulSoup(open(filename, 'r', encoding='utf-8'), features='html.parser')
    results_table = soup.select_one('table.tborder')
    updated_row = soup.select_one(f'tr#tr_thread_{thread_info["id"]}')
    if updated_row:
        num_link = int(updated_row.select_one(f'td#thread_{thread_info["id"]}_idx').text)
        last_message_count = int(re.compile(r'([0-9]+) mensajes').search(
            updated_row.select_one(f'div#thread_{thread_info["id"]}_msgcnt').text).group(1))
    else:
        num_link = len(results_table.select('tr[id^=tr_thread_]')) + 1
        last_message_count = 0
    if not updated_row or (last_message_count != len(thread_info['parsed_messages'])):
        table_entry = _build_table_entry(num_link, thread_info, thread_file_name)
        table_entry_soup = BeautifulSoup(table_entry, features='html.parser')
        if not updated_row:
            results_table.append(table_entry_soup)
        else:
            updated_row.insert_after(table_entry_soup)
            updated_row.decompose()
        with open(filename, 'w', encoding='utf-8') as new_file:
            new_file.write(str(soup))


def _update_saved_threads_page(thread_info, thread_file_name, thread_index_file=''):
    output_dir = vbulletin_session.output_dir
    if not thread_index_file:
        filename = os.path.join(output_dir, 'saved_threads.html')
    else:
        filename = os.path.join(output_dir, thread_index_file)
    _create_saved_threads_file(filename)
    _insert_thread_saved_threads_file(filename, thread_info, thread_file_name)


def save_search_results_as_index_page(links):
    index_file = _open_index_file(links.get('search_id', ''))
    for idx, link in enumerate(links):
        link_pattern = _build_table_entry(idx, link, thread_file_name='')
        index_file.write(link_pattern)
    index_file.write('</table></body></html>')
    index_file.close()


def get_thread_file_name(thread_id, thread_name):
    file_name = slugify(f'{thread_id}_{thread_name}', max_length=250) if thread_name else thread_id
    return file_name + '.html'


def generate_minimal_header():
    minimal_header = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ' \
                     '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html ' \
                     'xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="es"><head>' \
                     '<meta http-equiv="Content-Type" content="text/html"/>' \
                     '<meta charset="UTF-8">' \
                     '<meta name="description" content="" />' \
                     '<title></title>' \
                     '</head><body onload=""><a name="top"></a>'
    return io.StringIO(minimal_header)


def get_header_file():
    header_filename = os.path.join(vbulletin_session.config['VBULLETIN']['resources'], 'page_header.txt')
    if os.path.exists(header_filename):
        return open(header_filename, 'r', encoding='utf-8')
    else:
        return generate_minimal_header()


def open_thread_file(thread_filename, thread_name):
    thread_file = open(
        os.path.join(
            vbulletin_session.output_dir,
            thread_filename), 'a+', encoding='utf-8')
    with get_header_file() as header_file:
        for line in header_file:
            if line.startswith('<meta name="description"'):
                thread_file.write(
                    f'<meta name=\"description\" content=\"{thread_name}\" />')
            elif line.startswith('<title>'):
                thread_file.write('<title>' + thread_name + '</title>')
            else:
                thread_file.write(line)
    return thread_file


full_message_template = '<table id="post{post_id}" class="tborder-author" style="table-layout: fixed; width: 100%;" ' \
                        'width="100%" cellspacing="0" cellpadding="5" border="0" align="center"\n' \
                        '   <tbody>\n' \
                        '       <tr>\n' \
                        '           <td class="thead" style="font-weight:normal; ' \
                        'border: 1px solid #D1D1D1; border-right: 0px" width="175">{post_date}</td>\n' \
                        '           <td class="thead" style="font-weight:normal; ' \
                        'border: 1px solid #D1D1D1; border-left: 0px" align="right">' \
                        '#<a href="{base_url}showthread.php?t={thread_id}#post{post_id}" ' \
                        'rel="nofollow" id="postcount{post_id}"' \
                        'name="{post_index}"><strong>{post_index}</strong></a></td>\n' \
                        '       </tr>\n' \
                        '       <tr valign="top">\n' \
                        '           <td class="alt2" rowspan="2" style="border: 1px solid #D1D1D1; ' \
                        'border-top: 0px; border-bottom: 0px" width="175"><div id="postmenu_{post_id}">' \
                        '<a class="bigusername" href="{base_url}member.php?u={user_id}">{user_name}</a></div>' \
                        '<div class="smallfont">&nbsp;<br><a href="{base_url}member.php?u={user_id}">' \
                        '<img id="fcterremoto" class="avatar" ' \
                        'src="{avatar_url}" ' \
                        'alt="Avatar de {user_name}" title="Avatar de {user_name}" ' \
                        'width="120" height="68" border="0"></a></div></td>\n' \
                        '{message_text}' \
                        '       </tr>\n' \
                        '   </tbody>\n' \
                        '</table>'

regex_post_id = re.compile(r'#post([0-9]+)')
regex_link_to_thread = re.compile(r'showthread\.php\?t=([0-9]+)')
regex_link_to_message = re.compile(r'showthread\.php\?p=([0-9]+)')
regex_link_to_profile = re.compile(r'member\.php\?u=([0-9]+)')


def _fix_links_to_this_thread(thread_id, html_node):
    all_thread_links = html_node.find_all('a', {'href': regex_link_to_thread}, recursive=True)
    for link in all_thread_links:
        href_val = link.attrs.get('href', '')
        m = regex_link_to_thread.search(href_val)
        if m and (m.group(1) == thread_id):
            post_id = regex_post_id.search(href_val)
            link.attrs['href'] = f'#post{post_id.group(1) if post_id else href_val}'
        elif not urlparse(href_val).netloc:
            link.attrs['href'] = vbulletin_session.base_url + href_val


def _fix_links_to_posts_in_this_thread(html_node):
    all_posts_links = html_node.find_all('a', {'href': regex_link_to_message}, recursive=True)
    for link in all_posts_links:
        post_id = regex_post_id.search(link.attrs.get('href', ''))
        if post_id:
            link.attrs['href'] = f'#post{post_id.group(1)}'


def _fix_links_to_user_profiles(html_node):
    all_user_profiles = html_node.find_all('a', {'href': regex_link_to_profile}, recursive=True)
    for link in all_user_profiles:
        if not urlparse(link.attrs.get('href', '')).netloc:
            link.attrs['href'] = vbulletin_session.base_url + link.attrs.get('href', '')


def _fix_quotes_links(thread_id, mess_content: Tag | str = None) -> str:
    """
        Takes links to this thread and convert them to anchor links,
        so I can navigate the thread totally offline.
        Fixes relative links to include the forum base URL
    """
    if not mess_content:
        return
    html_node = mess_content if (isinstance(mess_content, Tag)) else (
        BeautifulSoup(mess_content, features='html.parser'))
    _fix_links_to_this_thread(thread_id, html_node)
    _fix_links_to_posts_in_this_thread(html_node)
    _fix_links_to_user_profiles(html_node)
    return mess_content.prettify(formatter='minimal')


def write_message_to_thread_file(thread_file, thread_id, message_id, message):
    fixed_message = _fix_quotes_links(thread_id, mess_content=message.get('message', None))
    message_str = full_message_template.format(
        base_url=vbulletin_session.base_url,
        anchor_name=message_id,
        post_id=message_id,
        post_date=message['date'],
        thread_id=thread_id,
        post_index=message['index'],
        user_id=message['author']['id'],
        user_name=message['author']['username'],
        avatar_url=message['author']['avatar'],
        message_text=fixed_message
    )
    _write_str_to_thread_file(thread_file=thread_file, table_str=message_str)


def _write_str_to_thread_file(thread_file, table_str, retries=10):
    if retries > 0:
        try:
            thread_file.write(table_str)
            return True
        except UnicodeEncodeError as uni_err:
            if uni_err.reason == 'surrogates not allowed':
                # problema con codificación de emojis
                table_str_2 = table_str.encode('utf-8', errors='surrogatepass')
            else:
                table_str_2 = table_str.encode('utf-8', errors='backlashreplace')
            return _write_str_to_thread_file(thread_file, str(table_str_2, encoding='utf-8', errors='ignore'),
                                             retries - 1)
        except Exception as err:
            print(f'{err}')
    return False


def close_thread_file(thread_file):
    thread_file.write('\n</body></html>')
    thread_file.close()
